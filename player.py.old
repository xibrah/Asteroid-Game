from panda3d.core import *
from direct.actor.Actor import Actor
from direct.showbase.DirectObject import DirectObject
import math

class Player(DirectObject):
    """Player character for the Asteroid Frontier game"""
    
    def __init__(self, base, render_node, map_system):
        """Initialize the player
        
        Args:
            base: The ShowBase instance
            render_node: The parent node to attach the player to
            map_system: Reference to the map system for collision detection
        """
        self.base = base
        self.render_node = render_node
        self.map_system = map_system
        
        # Player attributes
        self.move_speed = 5.0  # Units per second
        self.turn_speed = 90.0  # Degrees per second
        self.health = 100
        self.max_health = 100
        self.credits = 100
        self.level = 1
        self.experience = 0
        
        # Input tracking
        self.keys = {"forward": False, "backward": False, "left": False, "right": False,
                   "turn_left": False, "turn_right": False, "strafe_left": False, "strafe_right": False}
        
        # Create the player node
        self.create_player_model()
        
        # Set up collision detection
        self.setup_collision()
        
        # Set up key controls
        self.setup_controls()
        
        # A dictionary for camera modes and their associated settings
        self.camera_modes = {
            "first_person": {"offset": (0, 0, 0.8), "hpr": (0, 0, 0)},
            "third_person": {"offset": (0, -5, 3), "hpr": (0, -30, 0)},
            "top_down": {"offset": (0, 0, 20), "hpr": (0, -90, 0)}
        }
        self.current_camera_mode = "third_person"
        
        # Task to update player
        self.base.taskMgr.add(self.update_task, "player_update_task")
        
        # Near exit flag
        self.near_exit = False
        self.near_exit_node = None
    
    def create_player_model(self):
        """Create the player model"""
        # Try to load an animated actor if available
        try:
            self.actor = Actor("models/player/player-model",
                             {"walk": "models/player/player-walk",
                              "idle": "models/player/player-idle"})
            self.actor.reparentTo(self.render_node)
            self.node = self.actor
            
            # Start playing the idle animation
            self.actor.loop("idle")
            self.current_anim = "idle"
            
        except:
            # Fallback to a simple model if actor isn't available
            try:
                self.node = self.base.loader.loadModel("models/box")
                self.node.reparentTo(self.render_node)
                self.actor = None
            
            except:
                # Create a very simple box model if nothing else works
                cm = CardMaker("player_front")
                cm.setFrame(-0.3, 0.3, 0, 0.8)  # Height = 0.8
                
                self.node = NodePath("player")
                self.node.reparentTo(self.render_node)
                
                # Create a simple player shape with six faces (box)
                colors = [(0, 0, 1, 1), (0, 0, 0.8, 1), (0, 0.8, 0.5, 1), 
                        (0, 0.8, 0.5, 1), (0, 0.5, 0.8, 1), (0, 0.5, 0.8, 1)]
                
                for i, (h, p) in enumerate([(0, 0), (180, 0), (90, 0), (270, 0), (0, 90), (0, -90)]):
                    face = self.node.attachNewNode(cm.generate())
                    face.setHpr(h, p, 0)
                    face.setPos(0, 0 if i > 1 else -0.3 if i == 0 else 0.3, 0)
                    face.setColor(colors[i])
                
                self.actor = None
        
        # Scale and position the model
        self.node.setScale(0.8, 0.8, 0.8)
        
        # Default position
        self.node.setPos(0, 0, 0.5)  # Slightly above the ground
        
        # Set a tag for the player
        self.node.setTag("type", "player")
    
    def setup_collision(self):
        """Set up collision detection for the player"""
        # Create a collision solid
        self.coll_node = CollisionNode("player")
        self.coll_node.addSolid(CollisionCapsule(0, 0, 0.1, 0, 0, 0.7, 0.3))
        
        # Attach the collision node to the player
        self.coll_np = self.node.attachNewNode(self.coll_node)
        
        # Show the collision geometry for debugging (comment this out in production)
        #self.coll_np.show()
        
        # Create a traverser and handler for collisions
        self.traverser = CollisionTraverser()
        self.handler = CollisionHandlerPusher()
        
        # Add the pusher handler to the collision node
        self.handler.addCollider(self.coll_np, self.node)
        self.traverser.addCollider(self.coll_np, self.handler)
    
    def setup_controls(self):
        """Set up keyboard controls for the player"""
        # Movement keys (WASD)
        self.accept("w", self.set_key, ["forward", True])
        self.accept("w-up", self.set_key, ["forward", False])
        self.accept("s", self.set_key, ["backward", True])
        self.accept("s-up", self.set_key, ["backward", False])
        self.accept("a", self.set_key, ["strafe_left", True])
        self.accept("a-up", self.set_key, ["strafe_left", False])
        self.accept("d", self.set_key, ["strafe_right", True])
        self.accept("d-up", self.set_key, ["strafe_right", False])
        
        # Arrow keys for turning
        self.accept("arrow_left", self.set_key, ["turn_left", True])
        self.accept("arrow_left-up", self.set_key, ["turn_left", False])
        self.accept("arrow_right", self.set_key, ["turn_right", True])
        self.accept("arrow_right-up", self.set_key, ["turn_right", False])
        self.accept("arrow_up", self.set_key, ["forward", True])
        self.accept("arrow_up-up", self.set_key, ["forward", False])
        self.accept("arrow_down", self.set_key, ["backward", True])
        self.accept("arrow_down-up", self.set_key, ["backward", False])
        
        # Camera view modes
        self.accept("1", self.set_camera_mode, ["first_person"])
        self.accept("2", self.set_camera_mode, ["third_person"])
        self.accept("3", self.set_camera_mode, ["top_down"])
        
        # Interaction key
        self.accept("e", self.interact)
    
    def set_key(self, key, value):
        """Set the value of a key in the keys dictionary"""
        self.keys[key] = value
    
    def set_camera_mode(self, mode):
        """Change the camera view mode"""
        if mode in self.camera_modes:
            self.current_camera_mode = mode
            
            # Apply camera settings immediately
            self.update_camera()
            
            print(f"Camera mode changed to: {mode}")
    
    def update_camera(self):
        """Update the camera position and orientation based on current mode"""
        settings = self.camera_modes[self.current_camera_mode]
        
        # Get the player's position and orientation
        player_pos = self.node.getPos()
        player_h = self.node.getH()
        
        # Calculate camera position based on offset
        offset = settings["offset"]
        
        if self.current_camera_mode == "first_person":
            # First person camera is attached to player but at eye level
            self.base.camera.setPos(0, 0, offset[2])
            self.base.camera.setHpr(0, 0, 0)
            self.base.camera.reparentTo(self.node)
            
        elif self.current_camera_mode == "third_person":
            # Third person follows behind the player
            angle_rad = math.radians(player_h)
            sin_h = math.sin(angle_rad)
            cos_h = math.cos(angle_rad)
            
            cam_x = player_pos.x - sin_h * offset[1]
            cam_y = player_pos.y - cos_h * offset[1]
            cam_z = player_pos.z + offset[2]
            
            self.base.camera.setPos(cam_x, cam_y, cam_z)
            self.base.camera.setHpr(player_h, settings["hpr"][1], 0)
            self.base.camera.reparentTo(self.render_node)
            
        elif self.current_camera_mode == "top_down":
            # Top-down view is fixed above the player
            self.base.camera.setPos(player_pos.x, player_pos.y, offset[2])
            self.base.camera.setHpr(0, settings["hpr"][1], 0)
            self.base.camera.reparentTo(self.render_node)
    
    def set_position(self, x, y, z=None):
        """Set the player's position"""
        if z is None:
            z = self.node.getZ()
        self.node.setPos(x, y, z)
    
    def get_position(self):
        """Get the player's position"""
        return self.node.getPos()
    
    def update_task(self, task):
        """Task to update the player each frame"""
        dt = globalClock.getDt()  # Get time since last frame
        
        # Get the player's current position and heading
        pos = self.node.getPos()
        heading = self.node.getH()
        
        # Default to no movement
        move_dir = Vec3(0, 0, 0)
        should_move = False
        turning = False
        
        # Handle rotation
        if self.keys["turn_left"]:
            self.node.setH(heading + self.turn_speed * dt)
            turning = True
        if self.keys["turn_right"]:
            self.node.setH(heading - self.turn_speed * dt)
            turning = True
        
        # Calculate movement direction
        heading_rad = math.radians(heading)
        sin_h = math.sin(heading_rad)
        cos_h = math.cos(heading_rad)
        
        # Forward/backward movement
        if self.keys["forward"]:
            move_dir.x -= sin_h * self.move_speed * dt
            move_dir.y -= cos_h * self.move_speed * dt
            should_move = True
        if self.keys["backward"]:
            move_dir.x += sin_h * self.move_speed * dt
            move_dir.y += cos_h * self.move_speed * dt
            should_move = True
            
        # Strafe movement
        if self.keys["strafe_left"]:
            move_dir.x -= cos_h * self.move_speed * dt
            move_dir.y += sin_h * self.move_speed * dt
            should_move = True
        if self.keys["strafe_right"]:
            move_dir.x += cos_h * self.move_speed * dt
            move_dir.y -= sin_h * self.move_speed * dt
            should_move = True
        
        # Check if we need to update animation
        if should_move and self.actor is not None:
            if self.current_anim != "walk":
                self.actor.loop("walk")
                self.current_anim = "walk"
        elif self.actor is not None and self.current_anim != "idle":
            self.actor.loop("idle")
            self.current_anim = "idle"
        
        # Apply movement only after checking for collisions
        if should_move:
            # Perform collision traversal
            self.traverser.traverse(self.render_node)
            
            # Calculate the next position
            next_pos = pos + move_dir
            
            # Check if the next position is valid
            # For simplicity, we're just checking the map but not doing physics-based collisions here
            if self.map_system.is_valid_position(next_pos.x, next_pos.y):
                self.node.setPos(next_pos)
        
        # Update the camera
        self.update_camera()
        
        # Check for nearby exits
        self.check_for_exits()
        
        return task.cont
    
    def check_for_exits(self):
        """Check if the player is near an exit"""
        pos = self.node.getPos()
        exit_node = self.map_system.get_near_exit(pos.x, pos.y)
        
        if exit_node:
            self.near_exit = True
            self.near_exit_node = exit_node
        else:
            self.near_exit = False
            self.near_exit_node = None
    
    def interact(self):
        """Interact with the environment or NPCs"""
        # If near an exit, try to travel
        if self.near_exit:
            # The game might need to present a travel menu here
            print("Player interacted with an exit!")
            messenger.send("exit_interaction", [self.near_exit_node])
            return True
        
        # Check for nearby NPCs
        pos = self.node.getPos()
        
        # For now, just print a message
        print(f"Player pressed interact at {pos}")
        
        # Send an interaction message
        messenger.send("player_interact", [pos])
        
        return False
