from panda3d.core import *
from direct.showbase.DirectObject import DirectObject
import math

class CameraManager(DirectObject):
    """Manages camera control for the game"""
    
    def __init__(self, base, render_node):
        """Initialize the camera manager
        
        Args:
            base: The ShowBase instance
            render_node: The parent node the camera will be attached to
        """
        self.base = base
        self.render_node = render_node
        
        # Disable default mouse control
        self.base.disableMouse()
        
        # Camera settings
        self.default_camera_height = 1.8  # Eye level for first-person
        self.third_person_distance = 5.0  # Distance behind player for third-person
        self.third_person_height = 3.0    # Height above player for third-person
        self.third_person_pitch = -30     # Looking down angle for third-person
        self.top_down_height = 20.0       # Height for top-down view
        
        # Camera definitions
        self.modes = {
            "first_person": self.set_first_person,
            "third_person": self.set_third_person,
            "top_down": self.set_top_down,
        }
        
        # Current mode and target
        self.current_mode = "third_person"
        self.target = None
        
        # Key controls for switching views
        self.accept("1", self.set_mode, ["first_person"])
        self.accept("2", self.set_mode, ["third_person"])
        self.accept("3", self.set_mode, ["top_down"])
        
        # Camera transition parameters
        self.transition_speed = 0.1  # Lower is slower, 1.0 is instant
        self.transitioning = False
        self.transition_start_pos = None
        self.transition_end_pos = None
        self.transition_start_hpr = None
        self.transition_end_hpr = None
        self.transition_progress = 0.0
    
    def set_target(self, target):
        """Set the target for the camera to follow
        
        Args:
            target: The NodePath to follow
        """
        self.target = target
        self.update()
    
    def set_mode(self, mode, smooth_transition=True):
        """Set the camera mode
        
        Args:
            mode: Camera mode name
            smooth_transition: Whether to transition smoothly or instantly
        """
        if mode in self.modes and mode != self.current_mode:
            # If we want a smooth transition, set up the transition parameters
            if smooth_transition:
                self.start_transition(mode)
            else:
                self.current_mode = mode
                self.modes[mode]()
    
    def start_transition(self, target_mode):
        """Start a smooth transition to a new camera mode
        
        Args:
            target_mode: The camera mode to transition to
        """
        if self.transitioning:
            # If already transitioning, just change the end point
            self.transition_progress = 0.0
        else:
            # Start a new transition
            self.transitioning = True
            self.transition_progress = 0.0
            self.transition_start_pos = self.base.camera.getPos()
            self.transition_start_hpr = self.base.camera.getHpr()
            
            # Temporarily change mode to calculate end position
            old_mode = self.current_mode
            self.current_mode = target_mode
            
            # Calculate end position without actually moving the camera
            cam_pos = self.base.camera.getPos()
            cam_hpr = self.base.camera.getHpr()
            
            # Call the target mode function to calculate the target position
            self.modes[target_mode]()
            
            # Store the end position
            self.transition_end_pos = self.base.camera.getPos()
            self.transition_end_hpr = self.base.camera.getHpr()
            
            # Restore camera position and old mode
            self.base.camera.setPos(cam_pos)
            self.base.camera.setHpr(cam_hpr)
            self.current_mode = old_mode
            
            # Add the transition update task
            self.base.taskMgr.add(self.update_transition, "camera_transition")
    
    def update_transition(self, task):
        """Task to update camera position during transition"""
        if not self.transitioning:
            return task.done
        
        # Update transition progress
        self.transition_progress += self.transition_speed
        
        if self.transition_progress >= 1.0:
            # Transition complete
            self.transitioning = False
            self.current_mode = self.target_mode
            self.base.camera.setPos(self.transition_end_pos)
            self.base.camera.setHpr(self.transition_end_hpr)
            return task.done
        
        # Interpolate position and orientation
        t = self.transition_progress
        t = self.ease_out_cubic(t)  # Apply easing function
        
        # Linear interpolation
        pos = self.transition_start_pos * (1 - t) + self.transition_end_pos * t
        
        # Special handling for HPR to avoid issues with angle wrapping
        h1, p1, r1 = self.transition_start_hpr
        h2, p2, r2 = self.transition_end_hpr
        
        # Interpolate each angle considering wrap-around
        h = self.lerp_angle(h1, h2, t)
        p = self.lerp_angle(p1, p2, t)
        r = self.lerp_angle(r1, r2, t)
        
        # Apply new position and orientation
        self.base.camera.setPos(pos)
        self.base.camera.setHpr(h, p, r)
        
        return task.cont
    
    def ease_out_cubic(self, t):
        """Ease out cubic function for smoother transitions"""
        return 1 - (1 - t) ** 3
    
    def lerp_angle(self, a, b, t):
        """Interpolate between two angles with proper wrapping"""
        # Calculate the shortest path around the circle
        diff = (b - a + 180) % 360 - 180
        return a + diff * t
    
    def set_first_person(self):
        """Set the camera to first-person perspective"""
        if not self.target:
            return
        
        # Place camera at eye level in the player's head
        self.base.camera.reparentTo(self.target)
        self.base.camera.setPos(0, 0, self.default_camera_height)
        self.base.camera.setHpr(0, 0, 0)
    
    def set_third_person(self):
        """Set the camera to third-person perspective"""
        if not self.target:
            return
        
        # Get player position and heading
        player_pos = self.target.getPos()
        player_h = self.target.getH()
        
        # Convert heading to radians
        heading_rad = math.radians(player_h)
        
        # Calculate position behind and above the player
        offset_x = -math.sin(heading_rad) * self.third_person_distance
        offset_y = -math.cos(heading_rad) * self.third_person_distance
        
        # Set camera position and orientation
        self.base.camera.reparentTo(self.render_node)
        self.base.camera.setPos(
            player_pos.x + offset_x,
            player_pos.y + offset_y,
            player_pos.z + self.third_person_height
        )
        self.base.camera.setHpr(player_h, self.third_person_pitch, 0)
    
    def set_top_down(self):
        """Set the camera to top-down perspective"""
        if not self.target:
            return
        
        # Get player position
        player_pos = self.target.getPos()
        
        # Set camera position directly above player
        self.base.camera.reparentTo(self.render_node)
        self.base.camera.setPos(player_pos.x, player_pos.y, self.top_down_height)
        self.base.camera.setHpr(0, -90, 0)  # Looking straight down
    
    def update(self):
        """Update the camera position based on current mode"""
        if not self.target:
            return
            
        # If transitioning, let the transition task handle it
        if self.transitioning:
            return
            
        # Call the appropriate function for the current mode
        if self.current_mode in self.modes:
            self.modes[self.current_mode]()